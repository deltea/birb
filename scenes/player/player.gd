class_name Player extends CharacterBody2D

const win_star_scene = preload("res://scenes/win-star/win_star.tscn")

@export_category("Movement")
@export var max_speed = 150.0
@export var jump_velocity = 280.0
@export var gravity = 1000.0
@export var fall_gravity = 1400.0
@export var wall_fall_velocity = 80.0
@export var acceleration = 50.0
@export var deceleration = 30.0
@export var coyote_time = 0.15
@export var buffer_time = 0.15
@export var jump_cut_multiplier = 0.5
@export var bounce_velocity = 400.0
@export var dash_velocity = 420.0

@export_category("Animation")
@export var squash = 0.4
@export var stretch = 0.4

@onready var sprite: AnimatedSprite2D = $AnimatedSprite
@onready var walk_particles: CPUParticles2D = $WalkParticles
@onready var dash_particles: CPUParticles2D = $DashParticles
@onready var dash_timer: Timer = $DashTimer

var jumped = false
var coyote_timer = 0.0
var buffer_timer = buffer_time
var can_move = true
var target_scale = Vector2.ONE;
var target_rot = 0.0;
var is_dashing = false
var original_particles_x

@onready var scale_dynamics: DynamicsSolverVector = Dynamics.create_dynamics_vector(2.0, 0.5, 2.0);
@onready var rot_dynamics: DynamicsSolver = Dynamics.create_dynamics(10.0, 0.8, 10.0);

func _enter_tree() -> void:
	RoomManager.current_room.player = self

func _ready() -> void:
	original_particles_x = walk_particles.position.x

func _process(_dt: float) -> void:
	sprite.scale = scale_dynamics.update(target_scale);
	sprite.rotation_degrees = rot_dynamics.update(target_rot)
	dash_particles.emitting = is_dashing

func _physics_process(delta: float) -> void:
	coyote_timer += delta
	buffer_timer += delta

	var x_input := Input.get_axis("left", "right")

	if not is_on_floor() and not is_dashing and can_move:
		if velocity.y > 0:
			if is_on_wall() and x_input:
				velocity.y = wall_fall_velocity
			else:
				velocity.y += fall_gravity * delta
		else:
			velocity.y += gravity * delta

	if can_move:
		if x_input:
			velocity.x = move_toward(velocity.x, x_input * max_speed, acceleration)
			sprite.flip_h = x_input < 0
		else:
			if not is_dashing:
				velocity.x = move_toward(velocity.x, 0.0, deceleration)

	if not is_dashing and can_move:
		if x_input:
			if is_on_floor():
				# target_rot = sin(Clock.time * 20.0) * 15.0
				target_rot = velocity.x / max_speed * 15.0
				sprite.play("walk")
				walk_particles.emitting = true
				walk_particles.position.x = original_particles_x * x_input
			else:
				target_rot = velocity.x / max_speed * 15.0
				walk_particles.emitting = false
				sprite.play("idle")
		else:
			sprite.play("idle")
			target_rot = 0.0
			walk_particles.emitting = false

	if (Input.is_action_just_pressed("jump") or buffer_timer < buffer_time) and not jumped and can_move:
		if is_on_floor() or coyote_timer < coyote_time:
			velocity.y = -jump_velocity
			scale_dynamics.set_value(Vector2.ONE + Vector2(-stretch, stretch))
			rot_dynamics.set_value(sprite.rotation_degrees)
			jumped = true

	if Input.is_action_just_pressed("jump") and is_on_wall() and not is_on_floor() and can_move and x_input:
		velocity.y = -jump_velocity
		velocity.x = -x_input * max_speed * 1.5
		scale_dynamics.set_value(Vector2.ONE + Vector2(-stretch, stretch))
		rot_dynamics.set_value(sprite.rotation_degrees)
		jumped = true

	if Input.is_action_just_released("jump") and velocity.y < 0.0:
		velocity.y *= jump_cut_multiplier

	if Input.is_action_just_pressed("jump") and not is_on_floor():
		buffer_timer = 0.0

	if Input.is_action_just_pressed("dash") and not is_dashing and can_move:
		if Input.is_action_pressed("down") and not is_on_floor():
			dash_down()
		elif x_input:
			dash_horizontal(x_input)

	var was_on_floor = is_on_floor()
	move_and_slide()

	if not was_on_floor and is_on_floor():
		scale_dynamics.set_value(Vector2.ONE + Vector2(squash, -squash))
		jumped = false
	elif was_on_floor and not is_on_floor() and not jumped:
		coyote_timer = 0.0

	for i in get_slide_collision_count():
		var collision := get_slide_collision(i)
		if is_dashing:
			is_dashing = false
			if collision.get_collider() is Bouncepad:
				collision.get_collider().bounce()
				velocity.y = -bounce_velocity
			else:
				velocity.y = -100.0

func dash_horizontal(x_input: float):
	dash_timer.start()
	is_dashing = true
	velocity.x = x_input * dash_velocity * 1.5
	velocity.y = 0.0
	scale_dynamics.set_value(Vector2.ONE + Vector2(stretch, -stretch))
	RoomManager.current_room.camera.shake(0.1, 1.5)

func dash_down():
	is_dashing = true
	velocity.y = dash_velocity
	scale_dynamics.set_value(Vector2.ONE + Vector2(-stretch, stretch))
	RoomManager.current_room.camera.shake(0.1, 1.5)

func win():
	sprite.play("win")
	can_move = false
	velocity = Vector2.ZERO
	z_index = 20
	walk_particles.visible = false
	dash_particles.visible = false
	RoomManager.current_room.camera.shake(0.25, 4.0)
	var win_star := win_star_scene.instantiate() as WinStar
	win_star.position = position
	RoomManager.current_room.add_child(win_star)
	get_tree().paused = true
	RoomManager.current_room.complete()

func _on_dash_timer_timeout() -> void:
	is_dashing = false
